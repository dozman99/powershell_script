name: Transfer Build to Azure
on:
  workflow_dispatch:
    inputs:
      # build_path:
      #   description: Base path where builds are located
      #   required: true
      #   type: string
      semantic_version:
        description: Semantic version to locate the build
        required: true
        type: string
      azure_file_share_dest_path:
        description: Destination path to the second Azure file share (new server)
        required: true
        type: string
      # nfs_address:
      #   description: 'The NFS server address'
      #   required: true
      #   type: string
      # on_prem_map_drive:
      #   description: Drive letter for mounting the on-premises network drive
      #   default: 'Z:'
      #   required: false
      #   type: string
      # azure_dest_map_drive:
      #   description: Drive letter for mounting the new Azure file share destination
      #   default: 'Y:'
      #   required: false
      #   type: string
      resource_group:
        description: 'Azure Resource Group'
        required: true
        type: string
      vnet_name:
        description: 'Virtual Network Name'
        required: true
        type: string
      subnet_name:
        description: 'Subnet Name'
        required: true
        type: string
      nsg_name:
        description: ' Network Security Group Name'
        required: true
        type: string
jobs:
  # TransferBuild:
  #   # runs-on: [self-hosted, Windows, C2892M312]
  #   runs-on: windows-latest
  #   env:
  #     TEMP_DIR: "C:\\Temp"
  #     DESTINATION_PATH: "${{ inputs.azure_dest_map_drive }}\\builds\\UC_${{ inputs.semantic_version }}_${{ github.run_id }}"
  #     CHECKSUM_FILE: "C:\\Temp\\build_checksum.txt"

  #   steps:
  #     # Step 1: Mount On-Prem Network Drive
  #     - name: Mount On-Prem Network Drive
  #       run: |
  #         try {
  #             $existingMapping = net use ${{ inputs.on_prem_map_drive }}
  #             if ($existingMapping -ne $null) {
  #                 net use ${{ inputs.on_prem_map_drive }} /delete /yes
  #             }
  #             if (-not (Test-Path -Path "${{ inputs.on_prem_map_drive }}\")) {
  #                 net use ${{ inputs.on_prem_map_drive }} ${{ inputs.nfs_address }} /u:${{ secrets.BACKUP_JOB_USER }} "${{ secrets.BACKUP_JOB_PW }}"
  #             }
  #         } catch {
  #             Write-Error "Failed to mount On-Prem network drive: $_"
  #             exit 1
  #         }

  #     # Step 2: Fetch the build file using naming pattern
  #     - name: Fetch Build
  #       run: |
  #         try {
  #             $buildPath = Join-Path ${{ inputs.build_path }} "UC_${{ inputs.semantic_version }}"
  #             if (-not (Test-Path $buildPath)) {
  #                 Write-Error "Build not found at $buildPath. Please verify the build path and version."
  #                 exit 1
  #             }
  #             if (-not (Test-Path "${{ env.TEMP_DIR }}")) {
  #                 New-Item -ItemType Directory -Path "${{ env.TEMP_DIR }}"
  #             }
  #             Get-FileHash -Path "$buildPath" -Algorithm SHA256 | Out-File -FilePath "${{ env.CHECKSUM_FILE }}"
  #             Copy-Item -Path "$buildPath" -Destination "${{ env.TEMP_DIR }}" -Recurse
  #             $originalHash = Get-Content "${{ env.CHECKSUM_FILE }}"
  #             $transferredHash = Get-FileHash -Path "${{ env.TEMP_DIR }}" -Algorithm SHA256
  #             if ($originalHash -ne $transferredHash.Hash) {
  #                 Write-Error "Checksum mismatch: Data integrity compromised!"
  #                 exit 1
  #             }
  #         } catch {
  #             Write-Error "Failed to fetch and verify the build: $_"
  #             exit 1
  #         }

  #     # Step 3: Mount Azure File Share Destination
  #     - name: Mount Azure File Share Destination
  #       run: |
  #         try {
  #             $existingMapping = net use ${{ inputs.azure_dest_map_drive }}
  #             #not sure if the below works
  #             if ($existingMapping -ne $null -and $existingMapping -notmatch "\\${{ secrets.AZURE_STORAGE_ACCOUNT }}") {
  #                 Write-Error "The drive mapping is incorrect or points to a different location."
  #                 exit 1
  #             }
  #             if (-not (Test-Path -Path "${{ inputs.azure_dest_map_drive }}\")) {
  #                 net use ${{ inputs.azure_dest_map_drive }} "\\${{ secrets.AZURE_STORAGE_ACCOUNT }}.file.core.windows.net\${{ inputs.azure_file_share_dest_path }}" /u:${{ secrets.AZURE_STORAGE_ACCOUNT }} "${{ secrets.AZURE_STORAGE_KEY }}"
  #             }
  #         } catch {
  #             Write-Error "Failed to mount Azure File Share destination: $_"
  #             exit 1
  #         }

  #     # Step 4: Transfer Build to Azure File Share Destination
  #     - name: Transfer Build to Azure File Share Destination
  #       run: |
  #         try {
  #             if (-not (Test-Path "${{ env.DESTINATION_PATH }}")) {
  #                 New-Item -ItemType Directory -Path "${{ env.DESTINATION_PATH }}"
  #             }
  #             robocopy "${{ env.TEMP_DIR }}" "${{ env.DESTINATION_PATH }}" /E /Z /NFL
  #             $originalHash = Get-Content "${{ env.CHECKSUM_FILE }}"
  #             $transferredHash = Get-FileHash -Path "${{ env.DESTINATION_PATH }}" -Algorithm SHA256
  #             if ($originalHash -ne $transferredHash.Hash) {
  #                 Write-Error "Checksum mismatch: Data integrity compromised!"
  #                 exit 1
  #             }
  #         } catch {
  #             Write-Error "Failed to transfer build: $_"
  #             exit 1
  #         }

  #     # Step 5: Cleanup Temporary Directory
  #     - name: Cleanup Temporary Directory
  #       if: ${{ always() }}
  #       run: |
  #         try {
  #             if (Test-Path "${{ env.TEMP_DIR }}") {
  #                 Remove-Item -Path "${{ env.TEMP_DIR }}" -Recurse -Force
  #                 Write-Host "Temporary directory cleaned up."
  #             }
  #         } catch {
  #             Write-Error "Failed to clean up temporary directory: $_"
  #             exit 1
  #         }

  #     # Step 6: Cleanup Network Drives
  #     - name: Cleanup Network Drives
  #       if: ${{ always() }}
  #       run: |
  #         try {
  #             net use ${{ inputs.on_prem_map_drive }} /delete /yes
  #             net use ${{ inputs.azure_dest_map_drive }} /delete /yes
  #             Write-Host "Network drives cleaned up."
  #         } catch {
  #             Write-Error "Failed to clean up network drives: $_"
  #             exit 1
  #         }

  create_disposable_vm_for_image:
    uses: ./.github/workflows/image_creation.yml
    with:
      resource_group: ${{ inputs.resource_group}}
      vnet_name: ${{ inputs.vnet_name}}
      subnet_name: ${{ inputs.subnet_name}}
      version: ${{ inputs.semantic_version}}
      nsg_name: ${{ inputs.nsg_name}}
      storage_account_name: "tfstateconclase"
      file_share_name: "testing-sprint"
      storage_account_key: "?sv=2022-11-02&ss=bfqt&srt=sco&sp=rwdlacupiytfx&se=2024-12-06T01:09:57Z&st=2024-12-05T17:09:57Z&spr=https,http&sig=Id%2B%2BIjV0lhOv%2FYgRBL8NSJpLD6uVqbMKs7XAVQVfTnI%3D"
      source_files_path: ${{ inputs.azure_file_share_dest_path }}

    secrets:
      AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
