# @format
name: Transfer Build to Azure File Share with Integrity Check
on:
  workflow_dispatch:
    inputs:
      build_path:
        description: Base path where builds are located
        required: true
        type: string
      semantic_version:
        description: Semantic version to locate the build
        required: true
        type: string
      temp_directory:
        description: Temporary directory on the runner for processing the build
        default: 'C:\\Temp'
        required: false
        type: string
      hyperv_host_label:
        description: Label of host where vm lives, must be connected to repo conducting backup as runner
        required: true
        type: string
      azure_file_share_dest_path:
        description: Destination path to the second Azure file share (new server)
        required: true
        type: string
      nfs_address:
        description: 'The NFS server address'
        required: true
      on_prem_map_drive:
        description: Drive letter for mounting the on-premises network drive
        default: 'Z:'
        required: false
        type: string
      azure_dest_map_drive:
        description: Drive letter for mounting the new Azure file share destination
        default: 'Y:'
        required: false
        type: string
    secrets:
      AZURE_STORAGE_ACCOUNT:
        description: Azure storage account name
        required: true
      AZURE_STORAGE_KEY:
        description: Azure storage account key
        required: true
      BACKUP_JOB_USER:
        description: user with permissions for NFS
        required: true
      BACKUP_JOB_PW:
        description: user pw for NFS access
        required: true

jobs:
  TransferBuild:
    runs-on: [self-hosted, Windows, '${{ inputs.hyperv_host_label }}']
    env:
      TEMP_DIR: "${{ inputs.temp_directory }}"
      DESTINATION_PATH: "${{ inputs.azure_dest_map_drive }}\\builds\\UC_${{ inputs.semantic_version }}_${{ github.run_id }}"
      CHECKSUM_FILE: "${{ inputs.temp_directory }}\\build_checksum.txt"

    steps:
      # Step 1: Mount On-Prem Network Drive
      - name: Mount On-Prem Network Drive
        run: |
          try {
              $existingMapping = net use ${{ inputs.on_prem_map_drive }}
              if ($existingMapping -ne $null) {
                  net use ${{ inputs.on_prem_map_drive }} /delete /yes
              }
              if (-not (Test-Path -Path "${{ inputs.on_prem_map_drive }}\")) {
                  net use ${{ inputs.on_prem_map_drive }} ${{ inputs.nfs_address }} /u:${{ secrets.BACKUP_JOB_USER }} "${{ secrets.BACKUP_JOB_PW }}"
              }
          } catch {
              Write-Error "Failed to mount On-Prem network drive: $_"
              exit 1
          }

      # Step 2: Fetch the build file using naming pattern
      - name: Fetch Build
        run: |
          try {
              $buildPath = Join-Path ${{ inputs.build_path }} "UC_${{ inputs.semantic_version }}"
              if (-not (Test-Path $buildPath)) {
                  Write-Error "Build not found at $buildPath. Please verify the build path and version."
                  exit 1
              }
              if (-not (Test-Path "${{ env.TEMP_DIR }}")) {
                  New-Item -ItemType Directory -Path "${{ env.TEMP_DIR }}"
              }
              Get-FileHash -Path "$buildPath" -Algorithm SHA256 | Out-File -FilePath "${{ env.CHECKSUM_FILE }}"
              Copy-Item -Path "$buildPath" -Destination "${{ env.TEMP_DIR }}" -Recurse
              $originalHash = Get-Content "${{ env.CHECKSUM_FILE }}"
              $transferredHash = Get-FileHash -Path "${{ env.TEMP_DIR }}" -Algorithm SHA256
              if ($originalHash -ne $transferredHash.Hash) {
                  Write-Error "Checksum mismatch: Data integrity compromised!"
                  exit 1
              }
          } catch {
              Write-Error "Failed to fetch and verify the build: $_"
              exit 1
          }

      # Step 3: Mount Azure File Share Destination
      - name: Mount Azure File Share Destination
        run: |
          try {
              $existingMapping = net use ${{ inputs.azure_dest_map_drive }}
              #not sure if the below works
              if ($existingMapping -ne $null -and $existingMapping -notmatch "\\${{ secrets.AZURE_STORAGE_ACCOUNT }}") {
                  Write-Error "The drive mapping is incorrect or points to a different location."
                  exit 1
              }
              if (-not (Test-Path -Path "${{ inputs.azure_dest_map_drive }}\")) {
                  net use ${{ inputs.azure_dest_map_drive }} "\\${{ secrets.AZURE_STORAGE_ACCOUNT }}.file.core.windows.net\${{ inputs.azure_file_share_dest_path }}" /u:${{ secrets.AZURE_STORAGE_ACCOUNT }} "${{ secrets.AZURE_STORAGE_KEY }}"
              }
          } catch {
              Write-Error "Failed to mount Azure File Share destination: $_"
              exit 1
          }

      # Step 4: Transfer Build to Azure File Share Destination
      - name: Transfer Build to Azure File Share Destination
        run: |
          try {
              if (-not (Test-Path "${{ env.DESTINATION_PATH }}")) {
                  New-Item -ItemType Directory -Path "${{ env.DESTINATION_PATH }}"
              }
              robocopy "${{ env.TEMP_DIR }}" "${{ env.DESTINATION_PATH }}" /E /Z /NFL
              $originalHash = Get-Content "${{ env.CHECKSUM_FILE }}"
              $transferredHash = Get-FileHash -Path "${{ env.DESTINATION_PATH }}" -Algorithm SHA256
              if ($originalHash -ne $transferredHash.Hash) {
                  Write-Error "Checksum mismatch: Data integrity compromised!"
                  exit 1
              }
          } catch {
              Write-Error "Failed to transfer build: $_"
              exit 1
          }

      # Step 5: Cleanup Temporary Directory
      - name: Cleanup Temporary Directory
        if: ${{ always() }}
        run: |
          try {
              if (Test-Path "${{ env.TEMP_DIR }}") {
                  Remove-Item -Path "${{ env.TEMP_DIR }}" -Recurse -Force
                  Write-Host "Temporary directory cleaned up."
              }
          } catch {
              Write-Error "Failed to clean up temporary directory: $_"
              exit 1
          }

      # Step 6: Cleanup Network Drives
      - name: Cleanup Network Drives
        if: ${{ always() }}
        run: |
          try {
              net use ${{ inputs.on_prem_map_drive }} /delete /yes
              net use ${{ inputs.azure_dest_map_drive }} /delete /yes
              Write-Host "Network drives cleaned up."
          } catch {
              Write-Error "Failed to clean up network drives: $_"
              exit 1
          }

      # Step 7: Set Output Variables
      - name: Set Output Variables
        id: set_output
        run: |
          echo "semantic_version=${{ inputs.semantic_version }}" >> $GITHUB_OUTPUT
          echo "azure_file_share_dest_path=${{ inputs.azure_file_share_dest_path }}" >> $GITHUB_OUTPUT

    outputs:
      semantic_version: ${{ steps.set_output.outputs.semantic_version }}
      azure_file_share_dest_path: ${{ steps.set_output.outputs.azure_file_share_dest_path }}
